package eu.webtoolkit.jwt;

import java.util.*;
import java.util.regex.*;
import java.io.*;
import java.util.concurrent.locks.ReentrantLock;
import javax.servlet.http.*;
import eu.webtoolkit.jwt.*;
import eu.webtoolkit.jwt.chart.*;
import eu.webtoolkit.jwt.utils.*;
import eu.webtoolkit.jwt.servlet.*;

/**
 * Abstract base class for interactive areas in a widget
 * 
 * 
 * Use an WAbstractArea (or rather, one of its concrete implementations), to
 * define interactivity that applies on a part of a {@link WImage} or
 * {@link WPaintedWidget}. The area may be defined using different shapes
 * through {@link WRectArea}, {@link WCircleArea} or {@link WPolygonArea}.
 * <p>
 * 
 * @see WImage#addArea(WAbstractArea area)
 * @see WPaintedWidget#addArea(WAbstractArea area)
 */
public class WAbstractArea extends WObject {
	/**
	 * Destructor.
	 * 
	 * The are is automatically removed from the {@link WImage} or
	 * {@link WPaintedWidget} to which it was added.
	 * <p>
	 * 
	 * @see WImage#removeArea(WAbstractArea area)
	 * @see WPaintedWidget#removeArea(WAbstractArea area)
	 */
	public void destroy() {
		WImage i = this.getImage();
		if (i != null) {
			i.removeArea(this);
		}
		/* delete this.anchor_ */;
		if (this.impl_ != null)
			this.impl_.remove();
	}

	/**
	 * Specify that this area specifies a hole for another area.
	 * 
	 * When set to true, this area will define an area that does not provide
	 * interactivity. When it preceeds other, overlapping, areas, it acts as if
	 * it cuts a hole in those areas.
	 * <p>
	 * The default value is false.
	 * <p>
	 * 
	 * @see WAbstractArea#isHole()
	 */
	public void setHole(boolean hole) {
		this.hole_ = hole;
		this.repaint();
	}

	/**
	 * Returns whether this area specifies a hole.
	 * 
	 * @see WAbstractArea#setHole(boolean hole)
	 */
	public boolean isHole() {
		return this.hole_;
	}

	/**
	 * Set the destination URL.
	 * 
	 * By setting a destionation URL, the area behaves like a {@link WAnchor}.
	 * <p>
	 * By default, no destination URL is set (ref = &quot;&quot;).
	 * <p>
	 * This method should not be used when the area has been pointed to a
	 * dynamically generated resource using
	 * {@link WAbstractArea#setResource(WResource resource)}.
	 * <p>
	 * 
	 * @see WAbstractArea#setResource(WResource resource) <p>
	 *      <i><b>Note:</b>Even when no destination URL is set, in some
	 *      circumstances, a identity URL (&apos;#&apos;) will be set on the
	 *      underlying HTML &lt;area&gt; element (see also
	 *      {@link WAbstractArea#setCursor(Cursor cursor)}). </i>
	 *      </p>
	 */
	public void setRef(String ref) {
		this.createAnchorImpl();
		this.anchor_.ref_ = ref;
		this.repaint();
	}

	/**
	 * Returns the the destination URL.
	 * 
	 * When the area refers to a resource, the current resource URL is returned.
	 * <p>
	 * 
	 * @see WAbstractArea#setRef(String ref)
	 */
	public String getRef() {
		if (this.anchor_ != null) {
			return this.anchor_.ref_;
		} else {
			return "";
		}
	}

	/**
	 * Set a destination resource.
	 * 
	 * A resource specifies application-dependent content, which may be
	 * generated by your application on demand.
	 * <p>
	 * By setting a resource, the area behaves like a {@link WAnchor} that
	 * refers to the resource <i>resource</i>. The resource may be cleared by
	 * passing <i>resource</i> = 0.
	 * <p>
	 * The area does not assume ownership of the resource.
	 * <p>
	 * 
	 * @see WAbstractArea#setRef(String ref)
	 */
	public void setResource(WResource resource) {
		this.createAnchorImpl();
		this.anchor_.resource_ = resource;
		this.anchor_.resource_.dataChanged().addListener(this,
				new Signal.Listener() {
					public void trigger() {
						WAbstractArea.this.resourceChanged();
					}
				});
		this.setRef(resource.generateUrl());
	}

	/**
	 * Returns the destination resource.
	 * 
	 * Returns 0 if no resource has been set.
	 * <p>
	 * 
	 * @see WAbstractArea#setResource(WResource resource)
	 */
	public WResource getResource() {
		if (this.anchor_ != null) {
			return this.anchor_.resource_;
		} else {
			return null;
		}
	}

	/**
	 * Specify the location where the referred content should be displayed.
	 * 
	 * This configures the location where referred content should be displayed,
	 * that was specified using {@link WAbstractArea#setRef(String ref)} or
	 * {@link WAbstractArea#setResource(WResource resource)}.
	 * <p>
	 * By default, the reference is displayed in the application (
	 * {@link AnchorTarget#TargetSelf}). When the destination is an HTML
	 * document, the application is replaced with the new document. When the
	 * reference is a document that cannot be displayed in the browser, it is
	 * offered for download or opened using an external program, depending on
	 * browser settings.
	 * <p>
	 * By setting <i>target</i> to {@link AnchorTarget#TargetNewWindow}, the
	 * destination is displayed in a new browser window or tab.
	 * <p>
	 * 
	 * @see WAbstractArea#setRef(String ref)
	 * @see WAbstractArea#setResource(WResource resource)
	 * @see WAbstractArea#getTarget()
	 */
	public void setTarget(AnchorTarget target) {
		this.createAnchorImpl();
		this.anchor_.target_ = target;
		this.repaint();
	}

	/**
	 * Returns the location where the referred content should be displayed.
	 * 
	 * @see WAbstractArea#setTarget(AnchorTarget target)
	 */
	public AnchorTarget getTarget() {
		if (this.anchor_ != null) {
			return this.anchor_.target_;
		} else {
			return AnchorTarget.TargetSelf;
		}
	}

	/**
	 * Set an alternate text.
	 * 
	 * The alternate text should provide a fallback for browsers that do not
	 * display an image. If no sensible fallback text can be provided, an empty
	 * text is preferred over nonsense.
	 * <p>
	 * This should not be confused with {@link WAbstractArea#getToolTip()} text,
	 * which provides additional information that is displayed when the mouse
	 * hovers over the area.
	 * <p>
	 * The default alternate text is an empty text (&quot;&quot;).
	 * <p>
	 * 
	 * @see WAbstractArea#getAlternateText()
	 */
	public void setAlternateText(CharSequence text) {
		this.createAnchorImpl();
		this.anchor_.altText_ = WString.toWString(text);
		this.repaint();
	}

	/**
	 * Returns the alternate text.
	 * 
	 * @see WAbstractArea#setAlternateText(CharSequence text)
	 */
	public WString getAlternateText() {
		if (this.anchor_ != null) {
			return this.anchor_.altText_;
		} else {
			return new WString();
		}
	}

	/**
	 * Set the tooltip.
	 * 
	 * The tooltip is displayed when the cursor hovers over the area.
	 */
	public void setToolTip(CharSequence text) {
		this.impl_.setToolTip(text);
	}

	/**
	 * Returns the tooltip text.
	 * 
	 * @see WAbstractArea#setToolTip(CharSequence text)
	 */
	public WString getToolTip() {
		return this.impl_.getToolTip();
	}

	/**
	 * Define a style class.
	 */
	public void setStyleClass(String styleClass) {
		this.impl_.setStyleClass(styleClass);
	}

	/**
	 * Returns the style class.
	 * 
	 * @see WAbstractArea#setStyleClass(String styleClass)
	 */
	public String getStyleClass() {
		return this.impl_.getStyleClass();
	}

	/**
	 * Set the cursor.
	 * 
	 * This sets the mouse cursor that is shown when the mouse pointer is over
	 * the area. Most browsers only support PointingHandCursor, which is
	 * activated by a non-empty ref.
	 * <p>
	 * 
	 * @see WAbstractArea#setRef(String ref)
	 */
	public void setCursor(Cursor cursor) {
		this.impl_.getDecorationStyle().setCursor(cursor);
	}

	/**
	 * Returns the cursor.
	 * 
	 * @see WAbstractArea#setCursor(Cursor cursor)
	 */
	public Cursor getCursor() {
		return this.impl_.getDecorationStyle().getCursor();
	}

	public WImage getImage() {
		return ((this.impl_.getParent()) instanceof WImage ? (WImage) (this.impl_
				.getParent())
				: null);
	}

	private AreaWidget impl_;

	/**
	 * Event signal emitted when a keyboard key is pushed down.
	 * 
	 * The keyWentDown signal is the first signal emitted when a key is pressed
	 * (before the {@link WAbstractArea#keyPressed()} signal). Unlike
	 * {@link WAbstractArea#keyPressed()} however it is also emitted for
	 * modifier keys (such as &quot;shift&quot;, &quot;control&quot;, ...) or
	 * keyboard navigation keys that do not have a corresponding character.
	 * <p>
	 * 
	 * @see WAbstractArea#keyPressed()
	 * @see WAbstractArea#keyWentUp()
	 */
	public EventSignal1<WKeyEvent> keyWentDown() {
		return this.impl_.keyWentDown();
	}

	/**
	 * Event signal emitted when a &quot;character&quot; was entered.
	 * 
	 * The keyPressed signal is emitted when a key is pressed, and a character
	 * is entered. Unlike {@link WAbstractArea#keyWentDown()}, it is emitted
	 * only for key presses that result in a character being entered, and thus
	 * not for modifier keys or keyboard navigation keys.
	 * <p>
	 * 
	 * @see WAbstractArea#keyWentDown()
	 */
	public EventSignal1<WKeyEvent> keyPressed() {
		return this.impl_.keyPressed();
	}

	/**
	 * Event signal emitted when a keyboard key is released.
	 * 
	 * This is the counter-part of the {@link WAbstractArea#keyWentDown()}
	 * event. Every key-down has its corresponding key-up.
	 * <p>
	 * 
	 * @see WAbstractArea#keyWentDown()
	 */
	public EventSignal1<WKeyEvent> keyWentUp() {
		return this.impl_.keyWentUp();
	}

	/**
	 * Event signal emitted when enter was pressed.
	 * 
	 * This signal is emitted when the Enter or Return key was pressed.
	 * <p>
	 * 
	 * @see WAbstractArea#keyPressed()
	 * @see Key#Key_Enter
	 */
	public EventSignal enterPressed() {
		return this.impl_.enterPressed();
	}

	/**
	 * Event signal emitted when escape was pressed.
	 * 
	 * This signal is emitted when the Escape key was pressed.
	 * <p>
	 * 
	 * @see WAbstractArea#keyPressed()
	 * @see Key#Key_Escape
	 */
	public EventSignal escapePressed() {
		return this.impl_.escapePressed();
	}

	/**
	 * Event signal emitted when a mouse key was clicked on this widget.
	 * 
	 * The event details contains information such as the
	 * {@link WMouseEvent#getButton() button}, optional
	 * {@link WMouseEvent#getModifiers() keyboard modifiers}, and mouse
	 * coordinates relative to the {@link WMouseEvent#getWidget() widget}, the
	 * window {@link WMouseEvent#getWindow() window}, or the
	 * {@link WMouseEvent#getDocument() document}.
	 * <p>
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the event details contain
	 * invalid information. </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> clicked() {
		return this.impl_.clicked();
	}

	/**
	 * Event signal emitted when a mouse key was double clicked on this widget.
	 * 
	 * The event details contains information such as the
	 * {@link WMouseEvent#getButton() button}, optional
	 * {@link WMouseEvent#getModifiers() keyboard modifiers}, and mouse
	 * coordinates relative to the {@link WMouseEvent#getWidget() widget}, the
	 * window {@link WMouseEvent#getWindow() window}, or the
	 * {@link WMouseEvent#getDocument() document}.
	 * <p>
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> doubleClicked() {
		return this.impl_.doubleClicked();
	}

	/**
	 * Event signal emitted when a mouse key was pushed down on this widget.
	 * 
	 * The event details contains information such as the
	 * {@link WMouseEvent#getButton() button}, optional
	 * {@link WMouseEvent#getModifiers() keyboard modifiers}, and mouse
	 * coordinates relative to the {@link WMouseEvent#getWidget() widget}, the
	 * window {@link WMouseEvent#getWindow() window}, or the
	 * {@link WMouseEvent#getDocument() document}.
	 * <p>
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> mouseWentDown() {
		return this.impl_.mouseWentDown();
	}

	/**
	 * Event signal emitted when a mouse key was released on this widget.
	 * 
	 * The event details contains information such as the
	 * {@link WMouseEvent#getButton() button}, optional
	 * {@link WMouseEvent#getModifiers() keyboard modifiers}, and mouse
	 * coordinates relative to the {@link WMouseEvent#getWidget() widget}, the
	 * window {@link WMouseEvent#getWindow() window}, or the
	 * {@link WMouseEvent#getDocument() document}.
	 * <p>
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> mouseWentUp() {
		return this.impl_.mouseWentUp();
	}

	/**
	 * Event signal emitted when the mouse went out of this widget.
	 * 
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> mouseWentOut() {
		return this.impl_.mouseWentOut();
	}

	/**
	 * Event signal emitted when the mouse entered this widget.
	 * 
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> mouseWentOver() {
		return this.impl_.mouseWentOver();
	}

	/**
	 * Event signal emitted when the mouse moved over this widget.
	 * 
	 * <p>
	 * <i><b>Note:</b>When JavaScript is disabled, the signal will never fire.
	 * </i>
	 * </p>
	 */
	public EventSignal1<WMouseEvent> mouseMoved() {
		return this.impl_.mouseMoved();
	}

	private static class AnchorImpl {
		public String ref_;
		public WResource resource_;
		public AnchorTarget target_;
		public WString altText_;

		public AnchorImpl() {
			this.ref_ = "";
			this.resource_ = null;
			this.altText_ = new WString();
		}
	}

	private boolean hole_;
	private WAbstractArea.AnchorImpl anchor_;

	private void createAnchorImpl() {
		if (!(this.anchor_ != null)) {
			this.anchor_ = new WAbstractArea.AnchorImpl();
			this.anchor_.resource_ = null;
			this.anchor_.target_ = AnchorTarget.TargetSelf;
		}
	}

	private void resourceChanged() {
		this.setRef(this.anchor_.resource_.generateUrl());
	}

	protected WAbstractArea() {
		super();
		this.impl_ = new AreaWidget(this);
		this.hole_ = false;
		this.anchor_ = null;
	}

	protected void updateDom(DomElement element, boolean all) {
		if (!this.hole_ && this.anchor_ != null) {
			element.setAttribute("href", WWebWidget
					.fixRelativeUrl(this.anchor_.ref_));
			switch (this.anchor_.target_) {
			case TargetSelf:
				break;
			case TargetThisWindow:
				element.setAttribute("target", "_top");
				break;
			case TargetNewWindow:
				element.setAttribute("target", "_blank");
			}
			element.setAttribute("alt", this.anchor_.altText_.toString());
		} else {
			element.setAttribute("alt", "");
			if (this.hole_) {
				element.setAttribute("nohref", "nohref");
			}
		}
	}

	protected void repaint() {
		this.impl_.repaint();
	}

	WInteractWidget getImpl() {
		return this.impl_;
	}

	private void setImage(WImage image) {
		this.impl_.setParent(image);
	}

	static WAbstractArea areaForImpl(WWidget w) {
		AreaWidget aw = ((w) instanceof AreaWidget ? (AreaWidget) (w) : null);
		if (!(aw != null)) {
			throw new WtException(
					"WAbstractArea::areaForImpl could not dynamic_cast?");
		}
		return aw.getFacade();
	}
}
